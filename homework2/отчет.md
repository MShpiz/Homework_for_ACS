# Домашняя работа 2

План:
1.   Макет программы на С++
2.   Тесты для макета
3.   Перевод макета с С++ на ассемблер
4.   Тестирование программы на ассемблере

## 1. Макет программы на С++
Разработку программы деления целых чисел было решено начать с составления макета программы на языке программирования C++, из-за более простого процесса разработки. Основная идея программы работать только с положительными числами, а все случаи с отрицательными числами приводить к положительным. 

В процессе анализа работы операторов С++ были выявлены следующие зависимости: 

 |Знак делимого | Знак делителя | Знак частного | Знак остатка|
|--- | --- | --- | ----|
|+ | + | + | +|
|+ | - | - | +|
|- | + | - | -|
|- | - | + | -|

Основываясь на данном наблюдении была составлена программа, которую я попыталась приблизить к тому виду в которм она будет на асемблере. Её можно найти в файле c_plus_plus_version.cpp или ниже

```c++

#include <iostream>

int main()
{
    int remainder, divisor;
    int quotient = 0;
    int delta = 1;// дельта для получения отрицательного частного
    bool negative_remainder = false;
    std::cout << "Enter dividend: ";
    std::cin >> remainder;
    std::cout << "Enter divisor: ";
    std::cin >> divisor;

    // переменные в которых будет хранится результат от встроенного деления и взятия остатка
    int real_res = 0;
    int real_rem = 0;

    // проверяем делитель на равенство 0
    if (divisor == 0) {
        // в случае 0 посылаем в плохую концовку программы
        goto badending;
    }

    // вычисляем правильный результат
    real_res = remainder / divisor;
    real_rem = remainder % divisor;

    //начинаем шаманить

    // если делимое меньше 0 остаток должен быть тоже меньше 0 и частное должно быть отрицательным
    if (remainder < 0) {
        // меняем знак делимого
        remainder = 0 - remainder;
        negative_remainder = true;
        delta = 0 - delta;
    }

    // если делитель меньше 0 частное должно быть отрицательным только если делитель не отрицательный
    if (divisor < 0) {
        // меняем знак делителя
        divisor = 0 - divisor;
        delta = 0 - delta;
    }

    // если делить нечего пропускаем цикл
    if (divisor > remainder) {
        goto endloop;
    }

    // начинаем цикл деления двух положительных чисел
    loop:
    // собственно итерация деления
    remainder = remainder - divisor;

    // увеличиваем частное на знаковую дельту
    quotient = quotient + delta;

    // пока есть что делить делим
    if (remainder >= divisor) {
        goto loop;
    }

    // конец цикла
    endloop:

    // делаем остаток отрицательным при необходимости
    if (negative_remainder) {
        remainder = 0 - remainder;
    }

    // вывод того что получилось в результате шаманства
    std::cout << "quotient: " << quotient << ", remainder: " << remainder << std::endl;
    // вывод того что должно было получиться
    std::cout << "real quotient: " << real_res << ", real remainder: " << real_rem;
    return 0;

    // плохая концовка с сообщением об ощибке деления на 0
    badending:
    std::cout << "Error, division by zero";
    return 0;
}

```

## 2. Тесты для макета
Все тесты основаны на математических правилах деления реализованных в ЯП С++ и покрывают такие варианты входных данных как:
- все варианты расстановки знаков для делителя и делимого основываясь на таблице из предыдущего раздела
- деление большего по модулю числа на меньшее по модулю
- деление меньшего по модулю числа на большее по модулю
- деление нацело
- деление на 0
- деление 0 на число
- деление 0 на 0

Собственно сами тесты представлены в таблице ниже.

| № |Делимое | Делитель | Частное | Остаток |
|--- | --- | --- | ----| ---|
|**1**| 15 | 6 | 2 | 3 |
|**2**| 15 | -6 | -2 | 3 |
|**3**| -15 | 6 | -2 | -3 |
|**4**| -15 | -6 | 2 | -3 |
|**5**| 15 | 5 | 3 | 0 |
|**6**| 15 | -5 | -3 | 0 |
|**7**| -15 | 5 | -3 | 0 |
|**8**| -15 | -5 | 3 | 0 |
|**9**|2|19|0|2|
|**10**|2|-19|0|2|
|**11**|-2|19|0|-2|
|**12**|-2|-19|0|-2|
|**13**|0|19|0|0|
|**14**|0|-19|0|0|
|**15**|10|0|Сообщение об ошибке|
|**16**|0|0|Сообщение об ошибке|

Все тесты пройдены успешно можно приступать к переводу этого чуда на асемблер.

## 3. Перевод макета с С++ на ассемблер  
В процессе перевод выяснилось, что условия из всех условных операторов исходной программы на с++ нужно инвертировать для того чтобы, при их выполнении программа пропускала действия "из тела условного оператора". Вот итоговая программа:

``` asm
.data
    arg01:  .asciz "Enter dividend: "
    arg02:  .asciz "Enter divisor: "
    quotient_txt: .asciz "quotient: "
    remainder_txt: .asciz " remainder: "
    ln:     .asciz "\n"
    error: .asciz "Error, division by zero"
.text
	la 	a0, arg01   # Подсказка для ввода первого числа
        li 	a7, 4       
        ecall
        li      a7 5        # ввести дделимое
        ecall   
        mv      t0 a0            

        la 	a0, arg02   # Подсказка для ввода второго числа
        li 	a7, 4       
        ecall
        li      a7 5        # ввести делитель
        ecall               
        mv      t1 a0    
        
        beq	t1, zero, badending # проверка деления на 0
        
        li	t2, 1 # дельта
        li	t3, 0 # отрицательный остаток или нет
        li 	t4, 0 # частное
        
        # если делимое >= 0 пропускаем смену знака делимого и дельты и флага об отрицательном остатке
        bge	t0, zero, endfirstcomp 
        sub	t0, zero, t0
        sub	t2, zero, t2
        addi	t3, t3, 1
              
        endfirstcomp:    # конец первого условия
        # если делитель >= 0 пропускаем смену знака делителя и дельты
        bge	t1, zero, endsecondcomp 
        sub	t1, zero, t1
        sub	t2, zero, t2    
        
        endsecondcomp:  # конец второго условия
        
        blt 	t0, t1, endloop # если делимое меньше делителя пропускаем цикл
        
        loop: # цикл деления
       	sub 	t0, t0, t1 # вычитаем делитель из делимого
       	add	t4, t4, t2 # прибавляем дельту к частному
       	bge	t0, t1, loop # пока делимое больше или равно делителю делим
       
       endloop: # конец цикла
	
	beq 	t3, zero, printresult # если остаток должен быть неотрицательным переходим к печати результата
	sub 	t0, zero, t0 # меняем знак остатка
	
	printresult:   
	    
	la a0, quotient_txt       # Подсказка для выводимого результата
        li a7, 4            
        ecall
        
        mv     a0 t4   # переносим значение частного
        li      a7 1        # выводим частное
        ecall
        
        la a0, remainder_txt       # Подсказка для выводимого результата
        li a7, 4            
        ecall
        
        mv     a0 t0    # переносим значение остатка
        li      a7 1        # выводим остаток
        ecall
        
        la a0, ln       # перевод строки
        li a7, 4            
        ecall

        li	a7, 10 # окончание программы
        ecall         
                         
        badending:    
        la 	a0, error   # Подсказка для ввода первого числа
        li 	a7, 4       
        ecall
        li	a7, 10 # окончание программы
        ecall
```
## 4. Тестирование программы на ассемблере
